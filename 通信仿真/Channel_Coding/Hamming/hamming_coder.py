#!/usr/bin/env python3
# -*- coding: utf-8 -*-


"""
Created on Tue Dec 12 14:22:37 2023

@author: jack


C = [7,4,3] Hammning codes


"""


import numpy as np
import copy
import sys, os
from functools import reduce

import utility


class Hamming(object):
    def __init__(self, args):
        ## code parameters
        self.args = args
        self.codedim = 4         # 码的维数，编码前长度
        self.codelen = 7         # 码的长度，编码后长度，码字长度
        self.codechk = 3         # 校验位的个数
        self.coderate = 4/7      # 码率
        self.H = np.array([
                        [1, 0, 0, 1, 0, 1, 1],
                        [0, 1, 0, 0, 1, 1, 1],
                        [0, 0, 1, 1, 1, 0, 1]], dtype = np.int8)
        self.G = np.array([
                        [1, 0, 1, 1, 0, 0, 0],
                        [0, 1, 1, 0, 1, 0, 0],
                        [1, 1, 0, 0, 0, 1, 0],
                        [1, 1, 1, 0, 0, 0, 1]], dtype = np.int8)
        self.legal_codeword = np.zeros((2**self.codedim, self.codelen), dtype = np.int8)

        self.all_mesg = np.zeros((2**self.codedim, self.codedim), dtype = np.int8)
        for i in range(2**self.codedim):
            for j in range(self.codedim):
                self.all_mesg[i, j] = (i>>j) % 2
            for k in range(self.codelen):
                self.legal_codeword[i, k] = np.bitwise_xor.reduce(self.all_mesg[i] & self.G[:,k])
        return

    def encoder(self, uu):
        cc = np.zeros(self.codelen, dtype = np.int8)
        cc[self.codechk:] = uu
        for i in range(self.codechk):
            cc[i] = np.logical_xor.reduce(np.logical_and(uu[:], self.G[:,i]))
        return cc

    def decoder_hard(self, yy,  ):
        cc_hat = utility.hard_decision(yy)
        cpass = np.zeros(self.codechk, dtype = np.int8)
        syndrome = np.zeros(self.codechk, dtype = np.int8)
        for i in range(self.codechk):
            # parity_check = np.logical_xor.reduce(np.logical_and(cc_hat, self.decH[i,:]))
            syndrome[i] = np.bitwise_xor.reduce(cc_hat & self.H[i,:])
        if np.all(syndrome == cpass):
            pass
        else:
            diss = np.sum(np.abs(self.H - syndrome.reshape(-1,1)), axis = 0)
            idx = np.argmin(diss)
            cc_hat[idx] ^= 1
        uu_hat = cc_hat[self.codechk:]
        return uu_hat


    def decoder_soft(self, yy, ):
        llr_cc = np.log(np.clip(yy/(1-yy), a_min = 10e-10, a_max = 10e10))
        #  bits[i] = 1
        bpsk = np.where(self.legal_codeword == 0, 1, -1)
        idx = np.argmax(np.sum(bpsk*llr_cc, axis = 1))
        return self.legal_codeword[idx, self.codechk:]














































































































































































































































































































































































































































































































































































































































































































































































































