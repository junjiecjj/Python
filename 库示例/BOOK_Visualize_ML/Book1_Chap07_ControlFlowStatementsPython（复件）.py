









#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Bk1_Ch07_23
# 笛卡儿积


column1 = [1, 2, 3, 4]
column2 = ['a', 'b', 'c']


cartesian_product = [(x, y) for x in column1 for y in column2]

print(cartesian_product)


cartesian_product = [[(x, y) for x in column1] for y in column2]

for prod_idx in cartesian_product:
    print(prod_idx)



from itertools import product

cartesian_product = list(product(column1, column2))
print(cartesian_product)




###  3个字符全排列
import itertools
string = 'abc'
perms_all = itertools.permutations(string)
# 返回一个可迭代对象perms，其中包含了string的所有排列方式

# 全排列
for perm_idx in perms_all:
    print(''.join(perm_idx))





### 3个字符无放回取2个排列
import itertools
string = 'abc'
# 3个不放回取2个的排列
perms_2 = itertools.permutations(string, 2)
# 返回一个包含所有长度为2的排列的可迭代对象perms
for perm_idx in perms_2:
    print(''.join(perm_idx))





### 3个字符无放回取2个排列
import itertools
string = 'abc'

# 3个取2个的组合
combs_2 = itertools.combinations(string, 2)
# 返回一个包含所有长度为2的组合的可迭代对象combs_2

for combo_idx in combs_2:
    print(''.join(combo_idx))






# 3个字符有放回取2个排列
import itertools

string = 'abc'
# 定义元素列表
elements = list(string)
# 指定重复次数
repeat = 2
# 生成有放回排列
permutations = itertools.product(elements, repeat=repeat)
# 遍历并打印所有排列
for permutation_idx in permutations:
    print(''.join(permutation_idx))








#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




















































































































































































































































































































































































































































































































































































































































































































































































































