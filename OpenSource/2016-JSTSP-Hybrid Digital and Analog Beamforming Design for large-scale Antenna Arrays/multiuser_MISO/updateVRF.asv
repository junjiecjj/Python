


% Eq.(24)-(29)
function Vrf = updateVRF(N, Nrf, Ht, Vrf)
    epsilon = 0.001;
    diff = 1;
    pi_val = pi;
    fVrf_old = N * trace(pinv(Ht * Vrf * Vrf' * Ht'));
    it = 0;
    while (diff > epsilon) & (it < 30)
        it = it + 1;
        for J = 1:Nrf
            Vrfj = Vrf(:, [1:J-1, J+1:end]);
            Aj = Htilde * Vrfj * (Vrfj') * Ht';
            AjInv = pinv(Aj);
            Bj = Ht' * AjInv * AjInv * Ht;
            Dj = Ht' * AjInv * Htilde;
            for i = 1:N
                % 计算zeta和eta
                tempB = 0;
                tempD = 0;
                for m = 1:1:N
                    if m ~= i 
                        for n = 1:1:N
                            if n ~= i 
                                tempB = tempB + conj(Vrf(m,J)) * Bj(m,n) * Vrf(n,J);
                                tempD = tempD + conj(Vrf(m,J)) * Dj(m,n) * Vrf(n,J);
                            end
                        end
                    end
                end
                zetaBij = Bj(i,i) + 2*real(tempB);
                zetaDij = Dj(i,i) + 2*real(tempD);
                etaBij = Bj(i,:) * Vrf(:,J) - Bj(i,i)*Vrf(i,J);
                etaDij = Dj(i,:) * Vrf(:,J) - Dj(i,i)*Vrf(i,J);
                % 计算theta_1，theta_2
                cij = (1 + zetaDij) * etaBij - zetaBij * etaDij;
                % 检查 cij 是否为零
                if abs(cij) < 1e-15
                    % cij 太小，保持当前值
                    theta_opt = angle(Vrf(i, J));
                    Vrf(i, J) = exp(-1j * theta_opt);
                    continue;
                end
                % 计算比值，并限制在 [-1, 1] 范围内
                tt = asin(imag(cij) / abs(cij));
                if(real(cij)>=0)
                    phij = tt; 
                else 
                    phij = pi - tt; 
                end
                % 计算第二个 asin 的自变量
                zij = imag(2 * conj(etaBij) * etaDij);
                sin_arg = zij / abs(cij);

                sin_arg = max(-1, min(1, sin_arg));  % 截断
                theta_1 = -phij + asin(sin_arg);
                theta_2 = pi_val - phij - asin(sin_arg);
                % 评估两个候选解
                V_RF1 = exp(-1j * theta_1);
                V_RF2 = exp(-1j * theta_2);
                denom1 = 1 + zetaDij + 2 * real(conj(V_RF1) * etaDij);
                denom2 = 1 + zetaDij + 2 * real(conj(V_RF2) * etaDij);
                f1 = N * trace(pinv(Aj)) - N * (zetaBij + 2 * real(conj(V_RF1) * etaBij)) / denom1;
                f2 = N * trace(pinv(Aj)) - N * (zetaBij + 2 * real(conj(V_RF2) * etaBij)) / denom2;
                if(f1 <= f2)
                    theta_opt = theta_1; 
                else
                    theta_opt = theta_2;
                end
                Vrf(i,J) = exp(-1j*theta_opt);
            end
        end
        fVrf_new = N * trace(pinv(Ht * Vrf * (Vrf') * Ht'));
        diff = abs((fVrf_new - fVrf_old)/fVrf_new);
        fVrf_old = fVrf_new;
        fprintf('   Vrf: Iteration %d, fVrf_new = %.6f, diff = %.6f\n', it, fVrf_new, diff);
    end
end












