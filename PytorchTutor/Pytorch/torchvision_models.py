#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sun Apr 10 17:23:39 2022

@author: jack


你可以使用随机初始化的权重来创建这些模型。

import torchvision.models as models
resnet18 = models.resnet18()
alexnet = models.alexnet()
squeezenet = models.squeezenet1_0()
densenet = models.densenet_161()


import torchvision.models as models
#pretrained=True就可以使用预训练的模型
resnet18 = models.resnet18(pretrained=True)
alexnet = models.alexnet(pretrained=True)

torchvision.models.alexnet(pretrained=False, ** kwargs)
AlexNet 模型结构 paper地址

pretrained (bool) – True, 返回在ImageNet上训练好的模型。
torchvision.models.resnet18(pretrained=False, ** kwargs)
构建一个resnet18模型

pretrained (bool) – True, 返回在ImageNet上训练好的模型。
torchvision.models.resnet34(pretrained=False, ** kwargs)
构建一个ResNet-34 模型.

Parameters: pretrained (bool) – True, 返回在ImageNet上训练好的模型。

torchvision.models.resnet50(pretrained=False, ** kwargs)
构建一个ResNet-50模型

pretrained (bool) – True, 返回在ImageNet上训练好的模型。
torchvision.models.resnet101(pretrained=False, ** kwargs)
Constructs a ResNet-101 model.

pretrained (bool) – True, 返回在ImageNet上训练好的模型。
torchvision.models.resnet152(pretrained=False, ** kwargs)
Constructs a ResNet-152 model.

pretrained (bool) – True, 返回在ImageNet上训练好的模型。
torchvision.models.vgg11(pretrained=False, ** kwargs)
VGG 11-layer model (configuration “A”) - pretrained (bool) – True, 返回在ImageNet上训练好的模型。

torchvision.models.vgg11_bn(** kwargs)
VGG 11-layer model (configuration “A”) with batch normalization

torchvision.models.vgg13(pretrained=False, ** kwargs)
VGG 13-layer model (configuration “B”)

pretrained (bool) – True, 返回在ImageNet上训练好的模型。
torchvision.models.vgg13_bn(** kwargs)
VGG 13-layer model (configuration “B”) with batch normalization

torchvision.models.vgg16(pretrained=False, ** kwargs)
VGG 16-layer model (configuration “D”)

Parameters: pretrained (bool) – If True, returns a model pre-trained on ImageNet

torchvision.models.vgg16_bn(** kwargs)
VGG 16-layer model (configuration “D”) with batch normalization

torchvision.models.vgg19(pretrained=False, ** kwargs)
VGG 19-layer model (configuration “E”)

pretrained (bool) – True, 返回在ImageNet上训练好的模型。
torchvision.models.vgg19_bn(** kwargs)
VGG 19-layer model (configuration ‘E’) with batch normalization


"""
#=====================================================
#本文介绍 torchvision.models 如何使用。以 vgg16为例子

# 1) 导入预训练模型：

import torchvision
model = torchvision.models.vgg16(pretrained=True)


# 2) 只导入网络结构，不导入参数：

model = torchvision.models.vgg16(pretrained=False) #主要是这里改为False


# 3) 由于 pretrained 参数默认是 False，所以 2) 等价于：

model = torchvision.models.vgg16()



#=====================================================
#预训练模型可以通过设置pretrained=True来构建：
import torchvision.models as models

resnet18 = models.resnet18(pretrained=True)
vgg16 = models.vgg16(pretrained=True)
alexnet = models.alexnet(pretrained=True)
squeezenet = models.squeezenet1_0(pretrained=True)

#预训练模型期望的输入是RGB图像的mini-batch：(batch_size, 3, H, W)，并且H和W不能低于224。图像的像素值必须在范围[0,1]间，并且用均值mean=[0.485, 0.456, 0.406]和方差std=[0.229, 0.224, 0.225]进行归一化。
#如果只需要网络结构，不需要用与训练模型的参数来初始化，可以将pretrained = False
model = torchvision.models.densenet169(pretrained=False)
# 等价于：
model = torchvision.models.densenet169()

#举例子：
import torchvision.models as models

vgg16 = models.vgg16(pretrained = True) # 获取训练好的VGG16模型
pretrained_dict = vgg16.state_dict() # 返回包含模块所有状态的字典，包括参数和缓存
#运行上面的代码，开始下载vgg16模型。

#=====================================================
# https://www.jianshu.com/p/a7d1236ba964
#1. 以resnet18为例
import torchvision.models as models
import torch.nn as nn
model_ft = models.resnet18(pretrained=True)
num_ftrs = model_ft.fc.in_features
# Here the size of each output sample is set to 2.
# Alternatively, it can be generalized to nn.Linear(num_ftrs, len(class_names)).
model_ft.fc = nn.Linear(num_ftrs, 2)
#我们先将resnet18模型加载出来，预训练选择True，新模型的名字命名为model_ft，但是不清楚fc.in_features是什么意思，我们不妨将model_ft输出，得到如下结果：
#为了看起来简洁这里只截取了模型的最后两层，想知道详细输出内容可以自行尝试。我们再次将model_ft.fc输出，得到如下结果：


nn.Linear(in_features=512, out_features=1000, bias=True)

#可以看到，输出的是model_ft的fc层，那么in_fetures就是fc的输入个数，知道了最后一层的输入个数之后我们就能对预训练网络的最后一层进行替换，替换成我们想要的输出分类数目，例如我们最后的分类结果是一个二分类，则可以将代码写成

model_ft.fc = nn.Linear(num_ftrs, 2)
#其中num_ftres = model_ft.fc.in_features，这样我们的模型就建立好了。

#2.以VGG11为例
#VGG模型包含一个features模块和classifier，以VGG13为例，我们输出VGG的classifier模块，得到如下输出：

#所以需要对最后一个linear层进行替换，其思想与resnet网络类似：

num_ftrs = model_ft.classifier[6].in_features
model_ft.classifier[6] = nn.Linear(num_ftrs, 2)

#最后得到的model_ft模型即为输出为2的VGG13模型。










































































































































































































































































































































































































































































































































































































































































































































































































































































































